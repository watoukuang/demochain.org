# 数据结构
---
在学习任何技术之前，我总是习惯先思考：它的出现背后有什么深层次的意义？🤔 如果没有它，是否还有其他可行的解决方案？今天，我们来探讨一下Redis的背景，以及如果没有Redis，我们在使用Java时可能面临的挑战。

**1. 单机时代：用集合存储数据 🖥️**   
- **少量数据时**：我们可以直接用集合或现成的安全集合缓存数据，简单高效。⚡
- **数据量激增时**：当数据量飙升时，内存撑不住，`OutOfMemoryError` 直接让应用崩溃。💥

**2. 多实例时代：数据如何共享? 🔄**  
随着应用部署多个实例（比如：应用A和应用B），每个实例的内存是隔离的，集合里的数据无法直接共享。举个例子，用户登录后，应用A在内存中保存了Session数据，但应用B却无法访问到这个Session，导致用户必须重复登录。🔒

**针对上面两个问题，如果没有Redis，我们该怎么办？ 🤷‍♂️**

假设没有Redis的帮助，以下是我想出来的两种可能方案：

- **方案1：用数据库（如MySQL）当缓存**  
  尽管数据库能够存储数据，但它的访问速度无法与内存中的数据存取相比。而且，当系统面临高并发时，数据库很容易成为瓶颈，无法承载如此庞大的请求量。🐢

- **方案2：自己实现一个共享内存服务**  
  你可以尝试自定义一个共享内存服务，但这无疑会大大增加系统的复杂性，同时带来不小的稳定性风险。在没有Redis的情况下，开发者不仅需要处理内存管理，还要考虑高可用、故障恢复等复杂问题。⚙️ Redis的出现解决了在单机或多实例情况下的数据共享问题，并提供了极高的性能。它的出现让我们无需从头开始实现这些复杂的机制，可以专注于更高层次的业务逻辑，极大地提升了开发效率。🚀


把Redis的背后意义想明白后，接下来我们就来学习它的基本数据结构。Redis其实就是保存程序在执行过程中的状态。为了更好理解，我们可以将Redis的各个数据结构与Java中的集合类进行对比。📚

Redis的主要数据结构有：STRING(字符串)、LIST(列表)、SET(集合)、HASH(散列)、ZSET(有序集合)

## STRING（字符串）
### 基础操作

- SET 设置值
- GET 获取值
- DEL 删除值

```shell
127.0.0.1:6379> set hello world
OK
127.0.0.1:6379> get hello
"world"
127.0.0.1:6379> del hello
(integer) 1
127.0.0.1:6379> get hello
(nil)
127.0.0.1:6379>
```
常用API：
| API                     | 说明                                | 复杂度 |
|-------------------------|-------------------------------------|--------|
| get key                 | 获取key对应的value                  | O(1)   |
| set key value           | 设置key-value，不管key是否存在，都设置 | O(1)   |
| del key                 | 删除key-value                       | O(1)   |
| incr key                | key自增1，如果key不存在，自增后get(key)=1 | O(1)   |
| decr key                | key自减1，如果key不存在，自减后get(key)=-1 | O(1)   |
| incrby key k           | key自增k，如果key不存在，自增后get(key)=k | O(1)   |
| decrby key k           | key自减k，如果key不存在，自减后get(key)=-k | O(1)   |
| setnx key value         | key不存在，才设置                    | O(1)   |
| set key value xx       | key存在，才设置                     | O(1)   |
| mget key1 key2 key3 ...| 批量获取key，原子操作                | O(n)   |
| mset key1 value1 key2 value2 ... | 批量设置key-value          | O(n)   |
| getset key newvalue    | set key newvalue并返回旧的value     | O(1)   |
| append key value        | 将value追加到旧的value              | O(1)   |
| strlen key             | 返回字符串的长度（注意中文）        | O(1)   |
| incrbyfloat key 2.3    | 增加key对应的值2.3                  | O(1)   |
| getrange key start end  | 获取字符串指定下标的所有值          | O(1)   |
| setrange key index value| 设置指定下标（index）所有对应的值   | O(1)   |
 
::: tip
- EX 指定过期的秒时间，PX指定过期的毫秒时间
- NX：只有key不存在的时候，才设置成功
- XX：只有key存在的时候，才设置成功
- <span class="marker-text">5.0</span>支持set命令指定过期时间和不存在的时候才设置成功，<span class="marker-text">也就是通过一条命令就可以实现分布式锁加锁的功能</span>，以前的版本设置key和设置过期时间需要分成两个命令，原子性保证难度更大。
:::
### 使用场景
#### 场景1:热点数据缓存,分布式会话
热点数据缓存案例:
```shell
SET cache_key value EX 3600
```
#### 场景2:Setnx分布式锁
**获取锁:使用SET命令设置一个键，并设置过期时间。**
```shell
SET lock_key unique_identifier EX 10 NX
```
- lock_key：锁的键名。
- unique_identifier：一个唯一的标识符，通常是随机生成的 UUID，用于区分不同的锁持有者。
- EX 10：设置锁的过期时间为 10 秒，防止死锁。
- NX：仅在键不存在时设置键，确保只有一个客户端可以获得锁。

**释放锁:释放锁时，需要确保只有持有锁的客户端才能释放它。**
```shell
if (GET lock_key == unique_identifier) {
    DEL lock_key
}
```
检查当前持有者是否与 unique_identifier 匹配，只有匹配时才执行 DEL 命令。
### 场景3:Incr计数器/全局ID
计数器案例:
```shell
# 初始化计数器
SET counter_key 0

# 增加计数器
INCR counter_key   # counter_key 的值变为 1
INCR counter_key   # counter_key 的值变为 2

# 查看计数器值
GET counter_key    # 返回 2
```

### 场景5:Incr限流

### bit 操作,位图功能，在线用户统计 0/1标记 

### 底层原理


## LIST（列表）

列表可以有序存储多个字符串，其中字符串可以相同。

- LPUSH    将元素推入列表的左端

- RPUSH    将元素推入列表的右端

- LPOP    将元素从列表左端弹出

- RPOP    将元素从列表右端弹出

- LINDEX    获取列表在给定位置上的单个元素

- LRANGE     获取列表在给定范围的所有元素

```shell
127.0.0.1:6379> rpush list-key item
(integer) 2
127.0.0.1:6379> rpop list-key
"item"
127.0.0.1:6379> rpop list-key
"item"
127.0.0.1:6379> rpush list-key item
(integer) 1
127.0.0.1:6379> rpush list-key item2
(integer) 2
127.0.0.1:6379> rpush list-key item
(integer) 3
127.0.0.1:6379> lrange list-key 0 -1
1) "item"
2) "item2"
3) "item"
127.0.0.1:6379> lindex list-key 1
"item2"
127.0.0.1:6379> lpop list-key
"item"
127.0.0.1:6379> lrange list-key 0 -1
1) "item2"
2) "item"
127.0.0.1:6379>
```

常用API：

| API                           | 说明                             | 复杂度 |
|-------------------------------|----------------------------------|--------|
| lpush key value1 [value2]    | 将一个或多个值推入列表的左端     | O(1)   |
| rpush key value1 [value2]    | 将一个或多个值推入列表的右端     | O(1)   |
| linsert key before|after value newValue | 在list指定的值前|后插入newValue | O(n)   |
| lpop key                      | 移除并返回列表最左端的元素       | O(1)   |
| rpop key                      | 移除并返回列表最右端的元素       | O(1)   |
| ltrim key start end           | 按照索引范围修剪列表             | O(n)   |
| lindex key offset             | 返回列表中偏移量为offset的元素   | O(n)   |
| lrange key start end          | 获取列表指定索引范围所有元素     | O(n)   |
| llen key                      | 获取列表长度                     | O(1)   |
| lset key index newValue       | 设置列表指定索引值为newValue     | O(n)   |
| blpop key timeout             | lpop阻塞版本，timeout为阻塞超时时间，=0为不阻塞 | O(1)   |
| brpop key timeout             | rpop阻塞版本，timeout为阻塞超时时间，=0为不阻塞 | O(1)   |

## SET（集合）                   
集合可以存储不同多个字符串，且无序
- SADD    将元素添加到集合中

- SREM    从集合里面移除元素，如果这个元素存在

- SISMEMBER    快速检查一个元素是否已经存在集合中

- SMEMBERS    获取集合包含的所有元素（如果集合包含的元素非常多，那么命令执行速度回很慢，谨慎使用）

```shell
127.0.0.1:6379> sadd set-key item
(integer) 1
127.0.0.1:6379> sadd set-key item2
(integer) 1
127.0.0.1:6379> sadd set-key item3
(integer) 1
127.0.0.1:6379> sadd set-key item
(integer) 0
127.0.0.1:6379> smembers set-key
1) "item3"
2) "item2"
3) "item"
127.0.0.1:6379> sismember set-key item4
(integer) 0
127.0.0.1:6379> sismember set-key item
(integer) 1
127.0.0.1:6379> srem set-key item2
(integer) 1
127.0.0.1:6379> srem set-key item2
(integer) 0
127.0.0.1:6379> smembers set-key
1) "item3"
2) "item"
127.0.0.1:6379>
```
常用API：

| API                     | 说明                                    | 复杂度 |
|-------------------------|-----------------------------------------|--------|
| sadd key element        | 向集合key添加element（如果element已经存在，添加失败） | O(1)   |
| srem key element        | 将集合key中的element移除               | O(1)   |
| sismember key element   | 检查元素element是否存在于集合key中     | O(1)   |
| smembers key            | 返回集合包含的所有元素                  | O(N)   |


## HASH（散列）

Redis可以存储多个键值对之间的映射，hash 是一个string类型的field和value的映射表，适合存储对象。 
- HSET    在散列里面关联起给定的键值对
- HGET    获取指定散列键的值
- HGETALL    获取散列包含的所有键值对
- HDEL    如果给定键存在于散列里面，那么删除这个键

```shell
127.0.0.1:6379> hset hash-key sub-key1 value1
(integer) 1
127.0.0.1:6379> hset hash-key sub-key2 value2
(integer) 1
127.0.0.1:6379> hset hash-key sub-key1 value1
(integer) 0
127.0.0.1:6379> hgetall hash-key
1) "sub-key1"
2) "value1"
3) "sub-key2"
4) "value2"
127.0.0.1:6379> hdel hash-key sub-key2
(integer) 1
127.0.0.1:6379> hdel hash-key sub-key2
(integer) 0
127.0.0.1:6379> hget hash-key sub-key1
"value1"
127.0.0.1:6379> hgetall hash-key
1) "sub-key1"
2) "value1"
127.0.0.1:6379>
```

| API                             | 说明                                     | 复杂度 |
|---------------------------------|------------------------------------------|--------|
| hget key field                  | 获取hash key对应的field的value          | O(1)   |
| hset key field value            | 设置hash key对应的field的value          | O(1)   |
| hdel key field                  | 删除hash key对应的field的value          | O(1)   |
| hexists key field               | 判断hash key是否有field                 | O(1)   |
| hlen key                        | 获取hash key field的数量                 | O(1)   |
| hmget key field1 field2 ...     | 批量获取hash key的一批field对应的值     | O(n)   |
| hmset key field1 value1 field2 value2 ... | 批量设置hash key的一批field value | O(n)   |
| hgetall key                    | 返回hash key对应所有的field和value      | O(n)   |
| hvals key                      | 返回hash key对应所有field的value        | O(n)   |
| hkeys key                      | 返回hash key对应所有field                | O(n)   |
| hsetnx key field value          | 设置hash key对应的field的value（如果field已经存在，则失败） | O(1)   |
| hincrby key field intCounter    | hash key对应的field的value自增intCounter | O(1)   |
| hincrbyfloat key field floatCounter | hash key对应的field的value自增floatCounter | O(1)   |

## ZSET（有序集合）

有序集合和散列一样，都用于存储键值对：有序集合的键被称为成员（member），每个成员都是各不相同的；有序集合的值被称为分值（score），分值必须使用浮点数。有序集合是Redis里面唯一一个既可以根据成员访问元素，又可以根据分值以及分值的排列顺序来访问元素的结构。

使用场景：例如基于发表时间排序的文章列表、基于投票数量排序的文章列表等。

- ZADD    将一个带有给定分值的成员添加到有序集合里面
- ZRANGE    根据元素在有序排列中所处的位置，从有序集合中取出多个元素
- ZRANGEBYSCORE    获取有序集合在给定分值范围内的所有元素
- ZREM    如果给定成员存在于有序集合中，那么移除这个成员

```shell
127.0.0.1:6379> zadd zset-key 728 member1
(integer) 1
127.0.0.1:6379> zadd zset-key 985 member0
(integer) 1
127.0.0.1:6379> zadd zset-key 985 member0
(integer) 0
127.0.0.1:6379> zrange zset-key 0 -1 withscores
1) "member1"
2) "728"
3) "member0"
4) "985"
127.0.0.1:6379> zrangebyscore zset-key 0 800 withscores
1) "member1"
2) "728"
127.0.0.1:6379> zrem zset-key member1
(integer) 1
127.0.0.1:6379> zrem zset-key member1
(integer) 0
127.0.0.1:6379> zrange zset-key 0 -1 withscores
1) "member0"
2) "985"
127.0.0.1:6379>
```
 常用API：
| API                                      | 说明                                     | 复杂度         |
|------------------------------------------|------------------------------------------|----------------|
| zadd key score element                   | 添加score和element                      | O(logN)        |
| zrem key element                         | 删除元素                                | O(1)           |
| zscore key element                       | 返回元素的分数                          | O(1)           |
| zincrby key increScore element           | 增加或减少元素的分数                   | O(1)           |
| zcard key                               | 返回元素的总个数                        | O(1)           |
| zrange key start end [WITHSCORES]       | 返回指定索引范围内的升序元素【分值】  | O(log(n)+m)    |
| zrangebyscore key minScore maxScore [WITHSCORES] | 返回指定分数范围内的升序元素【分值】 | O(log(n)+m)    |
| zcount key minScore maxScore            | 返回有序集合内在指定分数范围内的个数  | O(log(n)+m)    |
| zremrangebyrank key start end           | 删除指定排名内的升序元素              | O(log(n)+m)    |
| zremrangebyscore key minScore maxScore  | 删除指定分数内的升序元素              | O(log(n)+m)    |

