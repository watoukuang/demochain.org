# 性能指标测试
在构建高并发、高可用的系统时，数据库性能指标是不可忽视的关键环节。尤其是像 MySQL 这样的传统关系型数据库，在面对大量并发请求时，如何确保数据的高效存取，避免因性能瓶颈导致系统崩溃或响应延迟，是开发者需要重点考虑的问题。

## 最大连接数
MySQL 的默认最大连接数配置用于控制数据库允许的最大客户端连接数。在不同版本的 MySQL 和 MariaDB 以及不同的运行环境中，默认的连接数有所不同。合理配置最大连接数能够避免因连接过多而导致的内存不足和系统性能问题。下面是不同版本下的MySQL默认最大连接数:

| MySQL 版本/环境   | 默认值 | 影响因素                                         |
|------------------|--------|--------------------------------------------------|
| MySQL 5.7（社区版） | 151    | 基于安全保守配置，避免内存耗尽                   |
| MySQL 8.0（社区版） | 151    | 同上                                             |
| MariaDB 10.x     | 151    | 与 MySQL 5.7 保持一致                            |
| 云数据库（如 RDS） | 2000~4000 | 云厂商优化，根据实例规格动态调整                  |
| Docker 容器（小内存） | 100~200 | 容器内存限制导致更低默认值                       |

### 连接数选定
**连接数选定的计算方法**  
为了合理配置最大连接数，需要了解每个连接所占用的内存空间，并根据服务器的可用内存和 InnoDB 缓冲池大小进行调整。连接数的计算公式如下：
- 每个连接占用内存 ≈ 4MB + sort_buffer_size + join_buffer_size
- 最大连接数 ≤ (可用内存 - InnoDB 缓冲池) / 每个连接内存  

具体来说，sort_buffer_size 和 join_buffer_size 会根据你的查询操作和数据表大小来变化，连接数的调整也需结合这些配置来进行优化。

**查看当前配置值**
```
SHOW VARIABLES LIKE 'sort_buffer_size';  -- 默认通常 256KB~2MB
SHOW VARIABLES LIKE 'join_buffer_size';  -- 默认通常 256KB~1MB
SHOW VARIABLES LIKE 'innodb_buffer_pool_size';  -- 默认通常为 128MB~8GB
```

### 优化建议
- 基于内存限制调整连接数：  
在内存较小的服务器中，应当限制最大连接数，避免因过多连接导致内存不足和系统崩溃。在大内存服务器中，可以适当增加最大连接数，但也要留有一定的内存余量给 InnoDB 缓冲池等其他操作。

- 动态调整连接数：
在生产环境中，尤其是在高并发的场景下，最大连接数的设置应根据负载的实际情况动态调整。可以结合监控工具（如 Prometheus、Grafana）监控系统负载，并实时调整。
- 合理设置应用的最大连接数：
如果系统包含多个业务数据库，建议为每个数据库设置合理的最大连接数。通过合理规划应用与数据库之间的连接池大小，可以避免因过多的数据库连接而导致性能下降或资源浪费。
- 考虑超时设置：
在连接数限制较高的情况下，还需合理设置连接的超时时间（如 wait_timeout 和 interactive_timeout），避免长时间占用的连接占用系统资源。建议设置合理的超时值，确保连接池中的连接能够有效释放。

### 注意事项
- 默认最大连接数设置是一个保守配置，适用于大多数场景，但在特定环境下可能需要根据实际业务需求进行调整。

- 在云数据库（如 RDS）等环境中，厂商会根据实例规格和业务负载动态调整连接数，因此用户不需要过多干预。

- 在容器化环境（如 Docker）中，由于内存资源限制，可能需要将最大连接数设置为较低的值，以避免容器内存溢出。

### 思考
#### mysql为什么默认值是151?
**历史原因**：早期 MySQL 为了避免低配置的服务器因为连接数过多导致内存溢出（OOM），所以将默认连接数设置得比较保守（151）。这个配置旨在平衡服务器的内存使用和系统稳定性。  
**现代化的优化**：随着硬件性能的提升，尤其是在云环境和大内存服务器上，MySQL 在一些环境（如云数据库和高配置的物理服务器）会自动优化连接数，以适应更高并发的业务需求。

## CRUD基础操作耗时统计

为了准确评估 MySQL 数据库在不同操作下的性能，我们使用了以下测试环境：

| **项**             | **描述**               |
|------------------|----------------------|
| **硬件**          | 4核8G 服务器，SSD 磁盘   |
| **数据量**        | 单表 100 万行数据       |
| **网络**          | 内网（延迟 <1ms）        |
| **索引类型**      | B+Tree（主键索引、二级索引） |
| **事务隔离级别**  | READ COMMITTED         |
| **网络环境**  | 内网环境（网络延迟 <1ms）        |



### 耗时对比(单位：ms)
| **操作类型**       | **无索引**         | **有索引（主键/二级）** | **关键影响因素**                  |
|--------------------|-------------------|-----------------------|---------------------------------|
| **Insert**         | 1~3 ms            | 1~3 ms                | 事务提交频率、缓冲池状态           |
| **Select**         | 10~1000+ ms       | 0.1~5 ms              | 全表扫描 vs 索引扫描               |
| **Update**         | 10~500 ms         | 1~10 ms               | 索引更新、行锁竞争                 |
| **Delete**         | 10~500 ms         | 1~10 ms               | 索引更新、表碎片化                 |

---

### 场景分析
#### 插入数据
- **无索引 vs 有索引**：耗时基本一致（B+Tree 索引插入成本低）。  
- **瓶颈**：  
  - 事务提交方式（`innodb_flush_log_at_trx_commit=1` 最安全但最慢）。  
  - 批量插入时建议使用 `INSERT ... VALUES (...), (...)` 减少网络往返。  

#### 查询数据
| **查询场景**         | **无索引耗时**      | **有索引耗时**        | **原因**                          |
|----------------------|-------------------|---------------------|---------------------------------|
| 主键查询（WHERE id=1）| 0.5~2 ms          | 0.1~1 ms            | 主键索引直接定位                  |
| 二级索引查询（WHERE name='xx'） | 10~1000 ms       | 0.5~3 ms            | 无索引需全表扫描                  |
| 范围查询（WHERE age>20） | 100~5000 ms      | 1~10 ms             | 索引范围扫描 vs 全表扫描           |

#### 更新数据
- **无索引**：  
  - 需先全表扫描定位数据（耗时与 `Select` 相同），再更新（+1~2 ms）。  
  - **示例**：`UPDATE users SET status=1 WHERE phone='13800138000'`（无索引）→ 100~500 ms。  
- **有索引**：  
  - 通过索引快速定位（0.1~2 ms），更新数据+索引（+1~3 ms）。  
  - **瓶颈**：行锁竞争（高并发时可能阻塞）。  

#### 删除数据
- **无索引**:全表扫描定位（同 `Select`），删除后可能产生表碎片。  
- **有索引**:快速定位，但需同步更新索引（InnoDB 实际是标记删除，不影响瞬时性能）。  

---

### 性能优化建议
#### 索引策略
- 主键索引：尽量使用自增 `BIGINT`，避免随机主键（如UUID）导致页分裂。  
- 高频查询字段：添加二级索引（如 `INDEX(name)`）。  
- 避免过度索引：每个索引会增加 `Insert/Update/Delete` 的维护成本。  

#### 写入优化
- 批量插入：用 `INSERT ... VALUES (...), (...)` 替代多次单条插入。  
- 调整事务提交：批量操作时设置 `innodb_flush_log_at_trx_commit=0`（需权衡安全性）。  

#### 查询优化
- 覆盖索引：`SELECT` 的字段尽量在索引中，避免回表。  
  ```sql
  -- 优化前（需回表）
  SELECT id, name FROM users WHERE age=20;
  
  -- 优化后（覆盖索引）
  ALTER TABLE users ADD INDEX idx_age_name(age, name);
  SELECT id, name FROM users WHERE age=20;  -- 直接走索引
  ```

#### 连接池配置
- 应用层连接池（如 Druid）设置合理的 `max_wait`，避免线程阻塞。  


