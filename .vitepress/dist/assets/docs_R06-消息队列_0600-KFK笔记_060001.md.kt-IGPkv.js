import{_ as t,C as r,c as i,o as n,j as e,G as p,ai as s,a as l}from"./framework-Cfw8I1ux.js";const k=JSON.parse('{"title":"消费模型","description":"","frontmatter":{},"headers":[],"relativePath":"docs/R06-消息队列/0600-KFK笔记/060001.md","filePath":"docs/R06-消息队列/0600-KFK笔记/060001.md"}'),c={name:"docs/R06-消息队列/0600-KFK笔记/060001.md"};function u(d,a,m,C,h,_){const o=r("ArticleMetadata");return n(),i("div",null,[a[0]||(a[0]=e("h1",{id:"消费模型",tabindex:"-1"},[l("消费模型 "),e("a",{class:"header-anchor",href:"#消费模型","aria-label":'Permalink to "消费模型"'},"​")],-1)),p(o),a[1]||(a[1]=s('<p>传统的消息队列模型的消息一旦被消费，就会从队列中被删除，而且只能被下游的一个Consumer 消费。这种模型的伸缩性很差，因为下游的多个 Consumer 都要抢这个共享消息队列的消息。发布订阅模型倒是允许消息被多个 Consumer 消费，但它的问题也是伸缩性不高，因为每个订阅者都必须要订阅主题的所有分区。这种全量订阅的方式既不灵活，也会影响消息的真实投递效果。</p><p>KFK引入了消费组的概念。KFK仅仅使用消费组这一种机制，却同时实现了传统消息系统的两大模型。如果所有实例都属于同一个 Group，那么它实现的就是消息队列模型。如果所有实例分别属于不同的 Group，那么它实现的就是发布订阅模型。</p><h2 id="消费方式" tabindex="-1">消费方式 <a class="header-anchor" href="#消费方式" aria-label="Permalink to &quot;消费方式&quot;">​</a></h2><p>Consumer 采用 Pull（拉取）模式从 Broker 中读取数据。</p><p>Pull 模式则可以根据 Consumer 的消费能力以适当的速率消费消息。Pull 模式不足之处是，如果 Kafka没有数据，消费者可能会陷入循环中，一直返回空数据。 因为消费者从 Broker 主动拉取数据，需要维护一个长轮询，针对这一点， Kafka 的消费者在消费数据时会传入一个时长参数 timeout。如果当前没有数据可供消费，Consumer 会等待一段时间之后再返回，这段时长即为 timeout。</p><h2 id="分区分配策略" tabindex="-1">分区分配策略 <a class="header-anchor" href="#分区分配策略" aria-label="Permalink to &quot;分区分配策略&quot;">​</a></h2><p>一个 Consumer Group 中有多个 Consumer，一个 Topic 有多个 Partition，所以必然会涉及到Partition 的分配问题，即确定哪个 Partition 由哪个 Consumer 来消费。 Kafka 有四种分配策略： 1.RoundRobin：针对集群中的所有topic；轮询的方式依次将分区分配给消费者。 2.Range，默认为Range：针对每个topic；通过 分区数 / 消费者数 决定每个消费者消费几个分区。如果除不尽则前面几个消费者会多消费1个分区（topic很多时容易产生数据倾斜）。 3.Sticky：首先会尽量均衡放置分区到消费者上面，出现同一消费组内消费者出现问题的时候，会尽量保持原有分配的分区不变化。 4.CooperativeSticky：在不停止消费的情况下进行增量再平衡。</p><p>可以通过参数partition.assignment.strategy来配置，默认是Range+ CooperativeSticky。</p><p>（1）Range(默认策略)。Range 方式是按照主题来分的，不会产生轮询方式的消费混乱问题。 假设有10个分区，3个消费者，排完序的分区将会是0,1,2,3,4,5,6,7,8,9；消费者线程排完序将会是C1-0,C2-0,C3-0。然后将partitions的个数除于消费者线程的总数来决定每个消费者线程消费几个分区。如果除不尽，那么前面几个消费者线程将会多消费一个分区。</p><p>回到例子，10个分 区，3个消费者线程， 10/3 = 3，而且除不尽，那么消费者线程 C1-0将会多消费一个分区。C1-0 将消费 0, 1, 2, 3 分区；C2-0将消费 4,5,6分区；C3-0将消费 7,8,9分区。</p><p>（2）RoundRobin。 RoundRobin 轮询方式将分区所有作为一个整体进行 Hash 排序，消费者组内分配分区个数最大差别为1，是按照组来分的，可以解决多个消费者消费数据不均衡的问题。 轮询分区策略是把所有partition和所有consumer线程都列出来，然后按照hashcode进行排序。最后通过轮询算法分配partition给消费线程。如果所有consumer实例的订阅是相同的，那么partition会均匀分布。 使用轮询分区策略必须满足两个条件： 1.每个主题的消费者实例具有相同数量的流。 2.每个消费者订阅的主题必须是相同的。</p><h2 id="消费者与分区的关系" tabindex="-1">消费者与分区的关系 <a class="header-anchor" href="#消费者与分区的关系" aria-label="Permalink to &quot;消费者与分区的关系&quot;">​</a></h2><p>一个消费者组：在 Kafka 中，消费者通常会被组织成一个消费者组（Consumer Group）。在同一个消费者组内，Kafka 会将主题的分区分配给组内的消费者。</p><p>消费者数量与分区数量的关系：</p><ul><li><p>如果消费者组内的消费者数量 小于分区数量，那么每个消费者会消费多个分区。</p></li><li><p>如果消费者组内的消费者数量 等于分区数量，那么每个消费者会消费一个分区。</p></li><li><p>如果消费者组内的消费者数量 大于分区数量，则有些消费者会空闲，未被分配到任何分区。</p></li></ul>',15))])}const K=t(c,[["render",u]]);export{k as __pageData,K as default};
